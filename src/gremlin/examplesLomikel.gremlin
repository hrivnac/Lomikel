// create personal graph in memory
// (Lomikel is a groovy class for accesss and manipulation of graphs)
graph1 = Lomikel.myGraph()
// create (or access) named graph "test" in the master HBase
// it is also possible to create graph in another HBase
//graph1 = Lomikel.myGraph('test')
// get access to this graph
g1 = graph1.traversal()
// you may want to define a schema for some elements in g1
// for example, if those elements have array types (List or Set)
// or if you want create an index on them
mgmt1 = graph1.openManagement()
PCA = mgmt1.makeVertexLabel('PCA').make()
pca00 = mgmt1.makePropertyKey('pca00').dataType(Double.class).cardinality(Cardinality.SINGLE).make() 
mgmt1.addProperties(PCA, pca00)
mgmt1.commit()
// create an instance of GremlinRecipies - a class with usefull methods for operations on graphs
gr = new GremlinRecipies(g)
// get any Vertex (10 * source)
// clone that vertex from the master graph (g) to personal graph (g1)
// last two (integer) arguments specify how far up/down should cloning go
// cloning doesn't clone loops, up goes all the way up (without going down), down goes just down 
// -1 means clone everything (it may be dangerous)
g.V().has('lbl', 'source').limit(10).each {source ->
  gr.gimme(source, g1, -1, -1)
  }
// commit new structure
graph1.tx().commit()
// Get GremlinRecipies for the private graph 'g1'
gr1 = new GremlinRecipies(g1)
// drop all '
Lomikel.drop(graph, 'distance', 100)
// scan all PCAs
// compute difference bewtween 'pca00' (that can be any formula using Vertex properties, giving double)
// if the result <= 0.5 then add an Edge with name 'distance' and a property 'difference' with the result value,
// do it only for 5 distances with the minimal value
// (commit after each Integer.MAX_VALUE new Edges, so do not commit)
// note: g1 does not have schema and indexes - so used variables should be specified 
gr1.structurise(g1.V().has('lbl', 'PCA'), 'pca00[0]-pca00[1]', 'pca00', 0.5, 5, 'distance', 'difference', Integer.MAX_VALUE)
// get some statistics about new Edges
g1.E().has('lbl', 'distance').values('difference').union(min(), max(), sum(), mean(), count())
// get the closest sources 
g1.E().has('lbl', 'distance').order().by('difference').limit(1).bothV().in().has('lbl', 'source').values('objectId')

// write your new Graph into a file
graph1.io(IoCore.gryo()).writeGraph('myfile.kryo')
// to read it later (maybe into another graph)
graph2.io(IoCore.gryo()).readGraph('myfile.kryo')



variables = 'pca00 pca01 pca02 pca03 pca04 pca05 pca06 pca07 pca08 pca09 pca10 pca11 pca12 pca13 pca14 pca15 pca16 pca17 pca18 pca19 pca20 pca21 pca22 pca23 pca24'
difference = 'Math.sqrt(' +
 'Math.pow(pca00[0]-pca00[1], 2.0)+' +
 'Math.pow(pca01[0]-pca01[1], 2.0)+' +
 'Math.pow(pca02[0]-pca02[1], 2.0)+' +
 'Math.pow(pca03[0]-pca03[1], 2.0)+' +
 'Math.pow(pca04[0]-pca04[1], 2.0)+' +
 'Math.pow(pca05[0]-pca05[1], 2.0)+' +
 'Math.pow(pca06[0]-pca06[1], 2.0)+' +
 'Math.pow(pca07[0]-pca07[1], 2.0)+' +
 'Math.pow(pca08[0]-pca08[1], 2.0)+' +
 'Math.pow(pca09[0]-pca09[1], 2.0)+' +
 'Math.pow(pca10[0]-pca10[1], 2.0)+' +
 'Math.pow(pca11[0]-pca11[1], 2.0)+' +
 'Math.pow(pca12[0]-pca12[1], 2.0)+' +
 'Math.pow(pca13[0]-pca13[1], 2.0)+' +
 'Math.pow(pca14[0]-pca14[1], 2.0)+' +
 'Math.pow(pca15[0]-pca15[1], 2.0)+' +
 'Math.pow(pca16[0]-pca16[1], 2.0)+' +
 'Math.pow(pca17[0]-pca17[1], 2.0)+' +
 'Math.pow(pca18[0]-pca18[1], 2.0)+' +
 'Math.pow(pca19[0]-pca19[1], 2.0)+' +
 'Math.pow(pca20[0]-pca20[1], 2.0)+' +
 'Math.pow(pca21[0]-pca21[1], 2.0)+' +
 'Math.pow(pca22[0]-pca22[1], 2.0)+' +
 'Math.pow(pca23[0]-pca23[1], 2.0)+' +
 'Math.pow(pca24[0]-pca24[1], 2.0)' +
 ')'
variables = 'pca00 pca01 pca02'
difference = 'EvaluatorFunctions.qdifference(new double[][]{pca00, pca01, pca02})'
gr = new GremlinRecipies(g)
gr.structurise(g.V().has('lbl', 'PCA'), difference, variables, 2, 0, 'distance', 'difference', 100)
